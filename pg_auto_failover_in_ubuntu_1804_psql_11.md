---
title: "[筆記] 在ubuntu 18.04安裝psql 11 以及 pg_auto_failover / install psql 11 and pg_auto_failover in ubuntu 18.04"
date: 2019-09-20T10:17:17+08:00
noSummary: false
featuredImage: "https://h.cowbay.org/images/post-default-11.jpg"
categories: ['筆記']
tags: ['postgresql','failover']
author: "Eric Chang"
keywords:
  - postgresql
  - pg_auto_failover
---

最近都在弄postgresql 

備份、還原測試得差不多了，就等著看到時候要用什麼方式

前幾天看到 pg_auto_failover 這個postgresql 的extension

https://github.com/citusdata/pg_auto_failover

感覺挺不錯的，看起來設定很簡單，雖然之前已經測試了 keepalived 做 HA

不過，反正當作練功嘛，多測試一套也不錯！

<!--more-->

基本的邏輯是 一台 monitor , 一台 master/primary node ，一台 slave/secondary node 組成一個cluster

當master/primary node 上面的 postgresql 服務死掉了，slave/secondary node 會自動接手

等到master/primary node 回來之後，會自動降級為 slave/secondary node

而原本的 slave/secondary node 就會變成 master/primary

***

#### 安裝相關套件

**以下步驟在三個node 都要操作**

安裝相依套件

```
sudo apt install make libssl1.0.0 libssl-dev libkrb5-3 libkrb5-dev libpq5 libpq-dev pgdg-keyring ssl-cert postgresql-plperl-11 postgresql-pltcl-11 postgresql-plpython-11 postgresql-plpython3-11 postgresql-11 postgresql-common postgresql-server-dev-11 postgresql-client-11 postgresql-client-common postgresql-doc-11 tcl8.6 libjson-perl tcl-tclreadline
```

安裝完成後，切換到postgres身份，把原本系統內的postgresql 檔存放目錄還有資料庫檔案目錄都清掉
```
sudo su - postgres
mv /etc/postgresql/11 /etc/postgresql/11.bak
mv /var/lib/postgresql/11 /var/lib/postgresql/11.bak
exit
```
開始安裝 pg_auto_failover 

```
curl https://install.citusdata.com/community/deb.sh | sudo bash
sudo apt install postgresql-11-auto-failover -y
```

postgresql 的相關執行檔路徑，預設不會載入到PATH變數中，所以要自己手動增加

直接加入 /etc/environment ，或者是去修改使用者的 .profile 載入正確的 $PATH 都可以
````
#replace PATH variable in /etc/environment
PATH="/usr/lib/postgresql/11/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"

```
因為要用 pg_auto_failover 來控制postgresql ，所以要把系統內建的服務先停掉，並且設定開啟不啟動
```
sudo systemctl disable postgresql
sudo systemctl stop postgresql
```

為了讓三台機器可以直接用hostname溝通，所以要修改 /etc/hosts
```
#add to /etc/hosts
192.168.11.151 monitor monitor.abc.com
192.168.11.152 pg-primary pg-primary.abc.com
192.168.11.153 pg-slave pg-slave.abc.com
```
以上完成在三台node上，安裝postgresql/pg_auto_failover 的工作

***

#### 設定 monitor node 

**在monitor node操作**

**建立monitor node**

```
sudo runuser -l postgres -c "/usr/bin/pg_autoctl create monitor --pgdata /var/lib/postgresql/11/main --pgport 5432 --nodename monitor"
```
這個步驟會在pg_hba.conf 中，新增一筆紀錄

```
host "pg_auto_failover" "autoctl_node" 192.168.11.0/24 trust # Auto-generated by pg_auto_failover
```

檢查一下狀態，看看有沒有安裝成功

```
2019-09-19 06:56:09 [administrator@monitor ~]$ sudo runuser -l postgres -c "psql -c '\'du"
                                     List of roles
  Role name   |                         Attributes                         | Member of 
--------------+------------------------------------------------------------+-----------
 autoctl      |                                                            | {}
 autoctl_node |                                                            | {}
 postgres     | Superuser, Create role, Create DB, Replication, Bypass RLS | {}


2019-09-19 06:56:15 [administrator@monitor ~]$ sudo runuser -l postgres -c "psql -c '\'l"
                                 List of databases
       Name       |  Owner   | Encoding  | Collate | Ctype |   Access privileges   
------------------+----------+-----------+---------+-------+-----------------------
 pg_auto_failover | autoctl  | SQL_ASCII | C       | C     | 
 postgres         | postgres | SQL_ASCII | C       | C     | 
 template0        | postgres | SQL_ASCII | C       | C     | =c/postgres          +
                  |          |           |         |       | postgres=CTc/postgres
 template1        | postgres | SQL_ASCII | C       | C     | =c/postgres          +
                  |          |           |         |       | postgres=CTc/postgres
(4 rows)
```

OK，看起來沒有問題

**啟動pg_auto_failover monitor**

```
2019-09-19 06:56:19 [administrator@monitor ~]$ sudo runuser -l postgres -c "pg_autoctl run --pgdata /var/lib/postgresql/11/main"
06:57:38 INFO  Managing PostgreSQL installation at "/var/lib/postgresql/11/main"
06:57:38 INFO  PostgreSQL is running in "/var/lib/postgresql/11/main" on port 5432
06:57:38 INFO  The version of extenstion "pgautofailover" is "1.0" on the monitor
06:57:38 INFO  pg_auto_failover monitor is ready at postgres://autoctl_node@monitor:5432/pg_auto_failover
06:57:38 INFO  Contacting the monitor to LISTEN to its events
```
這個指令會停留在console畫面上，要不就是在最後加上 ```&``` 放去背景執行

要不就是用systemd/supervisor 來控制，這個後面再來改

就先放著讓他跑，還可以順便觀察cluster變動時的狀態

再開一個terminal 跑底下的指令，產生monitor node 的URI ，在建立maser/slave node 的時候會用到

```
2019-09-19 06:58:39 [administrator@monitor ~]$ sudo runuser -l postgres -c "pg_autoctl show uri --pgdata /var/lib/postgresql/11/main"
postgres://autoctl_node@monitor:5432/pg_auto_failover
2019-09-19 06:59:01 [administrator@monitor ~]$
```

以上完成monitor node 的準備工作

***

#### 設定master/primary node

**建立pg_auto_failover master/primary node**

```
2019-09-19 15:04:16 [administrator@pg-primary ~]$ sudo runuser -l postgres -c "pg_autoctl create postgres --pgdata /var/lib/postgresql/11/main --pgport 5432 --nodename pg-primary --monitor postgres://autoctl_node@monitor:5432/pg_auto_failover"
15:04:19 INFO  Found pg_ctl for PostgreSQL 11.5 at /usr/lib/postgresql/11/bin/pg_ctl
15:04:19 INFO  Registered node pg-primary:5432 with id 1 in formation "default", group 0.
15:04:19 INFO  Writing keeper init state file at "/var/lib/postgresql/.local/share/pg_autoctl/var/lib/postgresql/11/main/pg_autoctl.init"
15:04:19 INFO  Successfully registered as "single" to the monitor.
15:04:21 INFO  Initialising a PostgreSQL cluster at "/var/lib/postgresql/11/main"
15:04:21 INFO  Postgres is not running, starting postgres
15:04:21 INFO   /usr/lib/postgresql/11/bin/pg_ctl --pgdata /var/lib/postgresql/11/main --options "-p 5432" --options "-h *" --wait start
15:04:21 INFO  CREATE DATABASE postgres;
15:04:21 INFO  The database "postgres" already exists, skipping.
15:04:21 INFO  FSM transition from "init" to "single": Start as a single node
15:04:21 INFO  Initialising postgres as a primary
15:04:21 INFO  Transition complete: current state is now "single"
15:04:21 INFO  Keeper has been succesfully initialized.
2019-09-19 15:04:21 [administrator@pg-primary ~]$
```

**啟動 pg_auto_failover master/primary node**

```
2019-09-19 15:14:34 [administrator@pg-primary ~]$ sudo runuser -l postgres -c "pg_autoctl run --pgdata /var/lib/postgresql/11/main"
15:15:11 INFO  Managing PostgreSQL installation at "/var/lib/postgresql/11/main"
15:15:11 INFO  The version of extenstion "pgautofailover" is "1.0" on the monitor
15:15:11 INFO  pg_autoctl service is starting
15:15:11 INFO  Calling node_active for node default/1/0 with current state: single, PostgreSQL is running, sync_state is "", WAL delta is -1.
15:15:16 INFO  Calling node_active for node default/1/0 with current state: single, PostgreSQL is running, sync_state is "", WAL delta is -1.
15:15:21 INFO  Calling node_active for node default/1/0 with current state: single, PostgreSQL is running, sync_state is "", WAL delta is -1.
```

一樣，執行完之後，會停留在畫面上，所以開另一個視窗來執行以下檢查的指令

```
2019-09-19 15:17:08 [administrator@pg-primary ~]$ sudo runuser -l postgres -c "pg_autoctl show state --pgdata /var/lib/postgresql/11/main"
      Name |   Port | Group |  Node |     Current State |    Assigned State
-----------+--------+-------+-------+-------------------+------------------
pg-primary |   5432 |     0 |     1 |            single |            single

2019-09-19 15:17:16 [administrator@pg-primary ~]$ 
```

以上，master/primary node 設定結束

***

####設定 slave/secondary node

**建立 pg_auto_failover slave/secondary node**

```
2019-09-19 07:04:08 [administrator@pg-slave ~]$ sudo runuser -l postgres -c "pg_autoctl create postgres --pgdata /var/lib/postgresql/11/main --pgport 5432 --nodename pg-slave --monitor postgres://autoctl_node@monitor:5432/pg_auto_failover"
07:19:57 INFO  Found pg_ctl for PostgreSQL 11.5 at /usr/lib/postgresql/11/bin/pg_ctl
07:19:57 INFO  Registered node pg-slave:5432 with id 2 in formation "default", group 0.
07:19:57 INFO  Writing keeper init state file at "/var/lib/postgresql/.local/share/pg_autoctl/var/lib/postgresql/11/main/pg_autoctl.init"
07:19:57 INFO  Successfully registered as "wait_standby" to the monitor.
07:19:57 INFO  FSM transition from "init" to "wait_standby": Start following a primary
07:19:57 INFO  Transition complete: current state is now "wait_standby"
07:20:02 INFO  FSM transition from "wait_standby" to "catchingup": The primary is now ready to accept a standby
07:20:02 INFO  The primary node returned by the monitor is pg-primary:5432
07:20:02 INFO  Initialising PostgreSQL as a hot standby
07:20:02 INFO  Running /usr/lib/postgresql/11/bin/pg_basebackup -w -h pg-primary -p 5432 --pgdata /var/lib/postgresql/11/backup -U pgautofailover_replicator --write-recovery-conf --max-rate 100M --wal-method=stream --slot pgautofailover_standby ...
07:20:04 INFO  pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/2000028 on timeline 1
pg_basebackup: starting background WAL receiver
    0/23751 kB (0%), 0/1 tablespace (...ostgresql/11/backup/backup_label)
13103/23751 kB (55%), 0/1 tablespace (...gresql/11/backup/base/13091/2602)
23761/23761 kB (100%), 0/1 tablespace (...esql/11/backup/global/pg_control)
23761/23761 kB (100%), 1/1 tablespace                                         
pg_basebackup: write-ahead log end point: 0/20000F8
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: base backup completed

07:20:04 INFO  Postgres is not running, starting postgres
07:20:04 INFO   /usr/lib/postgresql/11/bin/pg_ctl --pgdata /var/lib/postgresql/11/main --options "-p 5432" --options "-h *" --wait start
07:20:04 INFO  PostgreSQL started on port 5432
07:20:04 INFO  Transition complete: current state is now "catchingup"
07:20:04 INFO  Keeper has been succesfully initialized.
2019-09-19 07:20:04 [administrator@pg-slave ~]$
```
可以看到在建立slave/secondary node 的時候，就會開始第一次的同步

**啟動 pg_auto_failover slave/secondary node

```
2019-09-19 07:20:04 [administrator@pg-slave ~]$ sudo runuser -l postgres -c "pg_autoctl run --pgdata /var/lib/postgresql/11/main"
07:21:33 INFO  Managing PostgreSQL installation at "/var/lib/postgresql/11/main"
07:21:33 INFO  The version of extenstion "pgautofailover" is "1.0" on the monitor
07:21:33 INFO  pg_autoctl service is starting
07:21:33 INFO  Calling node_active for node default/2/0 with current state: catchingup, PostgreSQL is running, sync_state is "", WAL delta is -1.
07:21:33 INFO  FSM transition from "catchingup" to "secondary": Convinced the monitor that I'm up and running, and eligible for promotion again
07:21:33 INFO  Transition complete: current state is now "secondary"
07:21:34 INFO  Calling node_active for node default/2/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
07:21:39 INFO  Calling node_active for node default/2/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
```

開新視窗確認狀態

```
2019-09-19 07:22:03 [administrator@pg-slave ~]$ sudo runuser -l postgres -c "pg_autoctl show state --pgdata /var/lib/postgresql/11/main"
      Name |   Port | Group |  Node |     Current State |    Assigned State
-----------+--------+-------+-------+-------------------+------------------
pg-primary |   5432 |     0 |     1 |           primary |           primary
  pg-slave |   5432 |     0 |     2 |         secondary |         secondary

2019-09-19 07:22:45 [administrator@pg-slave ~]$ 
```

正常的話，應該就是會出現兩個 node ，一個 pg-primary 一個pg-slave

**generate URI for applications**

這個步驟是用來產生給client/applications 連線用的連線字串(connection string)

```
2019-09-19 07:29:56 [administrator@pg-slave ~]$ sudo runuser -l postgres -c "pg_autoctl show uri --formation default --pgdata /var/lib/postgresql/11/main"
postgres://pg-slave:5432,pg-primary:5432/postgres?target_session_attrs=read-write
2019-09-19 07:30:06 [administrator@pg-slave ~]$
```
以後就都通過這個URI來存取這個cluster

切記，**不可以用系統內建的postgresql service，一定要用 pg_auto_failover 來啟動DB**

以上 slave/secondary node 設定完成

***

設定上並不複雜，比起keepalived 要簡單太多了..

那就要評估看看在異常狀況發生，切換資料庫時的表現了

接下來就繼續測試auto failover 的功能！

***

#### 測試 auto failover 

首先，在 pg-prmiary node 上，透過上面產生的URI來進入psql

然後建立一個測試db、建立一個測試table，插入幾筆資料

```
2019-09-20 10:58:21 [administrator@pg-primary ~]$ sudo runuser -l postgres -c "psql postgres://pg-slave:5432,pg-primary:5432/postgres?target_session_attrs=read-write"
psql (11.5 (Ubuntu 11.5-1.pgdg18.04+1))
Type "help" for help.

postgres=# create database testdb_1058;
CREATE DATABASE
postgres=# create table testtbl (serial int);
CREATE TABLE
postgres=# insert into testtbl values (111);
INSERT 0 1
postgres=# insert into testtbl values (222);
INSERT 0 1
postgres=# insert into testtbl values (3);
INSERT 0 1
postgres=# insert into testtbl values (444);
INSERT 0 1
postgres=# select * from testtbl;
 serial 
--------
    111
    222
      3
    444
(4 rows)

postgres=# \q
2019-09-20 10:59:30 [administrator@pg-primary ~]$
```

然後切換到 pg-slave ，一樣透過URI進入psql 撈看看資料

```
2019-09-20 03:02:12 [administrator@pg-slave ~]$ sudo runuser -l postgres -c "psql postgres://pg-slave:5432,pg-primary:5432/postgres?target_session_attrs=read-write"
psql (11.5 (Ubuntu 11.5-1.pgdg18.04+1))
Type "help" for help.

postgres=# select * from testtbl;
 serial 
--------
    111
    222
      3
    444
(4 rows)

postgres=# 
```

確認透過URI的確是可以正常的存取資料

在兩台單機上(master/slave)上也都可以看到同樣的資料，代表資料有正確的被同步到兩台node上

**pg-slave**

```
2019-09-20 03:03:06 [administrator@pg-slave ~]$ sudo runuser -l postgres -c psql
psql (11.5 (Ubuntu 11.5-1.pgdg18.04+1))
Type "help" for help.

postgres=# \l
                              List of databases
    Name     |  Owner   | Encoding  | Collate | Ctype |   Access privileges   
-------------+----------+-----------+---------+-------+-----------------------
 nexus       | postgres | SQL_ASCII | C       | C     | 
 postgres    | postgres | SQL_ASCII | C       | C     | 
 template0   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 template1   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 testdb_1058 | postgres | SQL_ASCII | C       | C     | 
(5 rows)

postgres=# select * from testtbl;
 serial 
--------
    111
    222
      3
    444
(4 rows)

postgres=#
```

**pg-master**
```
2019-09-20 10:59:30 [administrator@pg-primary ~]$ sudo runuser -l postgres -c psql
psql (11.5 (Ubuntu 11.5-1.pgdg18.04+1))
Type "help" for help.

postgres=# \l
                              List of databases
    Name     |  Owner   | Encoding  | Collate | Ctype |   Access privileges   
-------------+----------+-----------+---------+-------+-----------------------
 nexus       | postgres | SQL_ASCII | C       | C     | 
 postgres    | postgres | SQL_ASCII | C       | C     | 
 template0   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 template1   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 testdb_1058 | postgres | SQL_ASCII | C       | C     | 
(5 rows)

postgres=# select * from testtbl;
 serial 
--------
    111
    222
      3
    444
(4 rows)

postgres=# 
```

接著來把本來是master的機器關掉，看看會有什麼變化

首先，在pg-slave 這台機器上，就會看到cluster 有狀況，primary 不見了
```
03:06:02 INFO  Calling node_active for node default/4/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
03:06:08 INFO  Calling node_active for node default/4/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
03:06:13 INFO  Calling node_active for node default/4/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
03:06:18 ERROR PostgreSQL cannot reach the primary server: the system view pg_stat_wal_receiver has no rows.
03:06:18 INFO  Calling node_active for node default/4/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is -1.
03:06:23 ERROR PostgreSQL cannot reach the primary server: the system view pg_stat_wal_receiver has no rows.
03:06:23 INFO  Calling node_active for node default/4/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is -1.
03:06:28 ERROR PostgreSQL cannot reach the primary server: the system view pg_stat_wal_receiver has no rows.
03:06:28 INFO  Calling node_active for node default/4/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is -1.
03:06:33 ERROR PostgreSQL cannot reach the primary server: the system view pg_stat_wal_receiver has no rows.
03:06:33 INFO  Calling node_active for node default/4/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is -1.
03:06:38 ERROR PostgreSQL cannot reach the primary server: the system view pg_stat_wal_receiver has no rows.
03:06:38 INFO  Calling node_active for node default/4/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is -1.
```

這時候在pg-slave 還能不能透過URI 連線進去psql操作？
```
2019-09-20 03:08:06 [administrator@pg-slave ~]$ sudo runuser -l postgres -c "psql postgres://pg-slave:5432,pg-primary:5432/postgres?target_session_attrs=read-write"
psql (11.5 (Ubuntu 11.5-1.pgdg18.04+1))
Type "help" for help.

postgres=# \l
                              List of databases
    Name     |  Owner   | Encoding  | Collate | Ctype |   Access privileges   
-------------+----------+-----------+---------+-------+-----------------------
 nexus       | postgres | SQL_ASCII | C       | C     | 
 postgres    | postgres | SQL_ASCII | C       | C     | 
 template0   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 template1   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 testdb_1058 | postgres | SQL_ASCII | C       | C     | 
(5 rows)

postgres=# create database testdb_1108;
CREATE DATABASE
postgres=# create table testtbl_1108 (serial int);
CREATE TABLE
postgres=# insert into testtbl_1108 values (999);
INSERT 0 1
postgres=# insert into testtbl_1108 values (888);
INSERT 0 1
postgres=# insert into testtbl_1108 values (77);
INSERT 0 1
postgres=# insert into testtbl_1108 values (66);
INSERT 0 1
postgres=# insert into testtbl_1108 values (55);
INSERT 0 1
postgres=# \q
2019-09-20 03:09:34 [administrator@pg-slave ~]$
```

很好，看起來沒有問題，這時候把 pg-primary 打開，執行啟動 pg_auto_failover node 的指令，看看會發生什麼事

```
2019-09-20 11:12:13 [administrator@pg-primary ~]$ sudo runuser -l postgres -c "pg_autoctl run"
11:12:29 INFO  Managing PostgreSQL installation at "/var/lib/postgresql/11/main"
11:12:29 INFO  The version of extenstion "pgautofailover" is "1.0" on the monitor
11:12:29 INFO  pg_autoctl service is starting
11:12:29 INFO  Calling node_active for node default/1/0 with current state: primary, PostgreSQL is not running, sync_state is "", WAL delta is -1.
11:12:29 INFO  Postgres is not running, starting postgres
11:12:29 INFO   /usr/lib/postgresql/11/bin/pg_ctl --pgdata /var/lib/postgresql/11/main --options "-p 5432" --options "-h *" --wait start
11:12:30 WARN  PostgreSQL was not running, restarted with pid 1407
11:12:30 INFO  FSM transition from "primary" to "demoted": A failover occurred, no longer primary
11:12:30 INFO  Transition complete: current state is now "demoted"
11:12:30 INFO  Calling node_active for node default/1/0 with current state: demoted, PostgreSQL is not running, sync_state is "", WAL delta is -1.
11:12:30 INFO  FSM transition from "demoted" to "catchingup": A new primary is available. First, try to rewind. If that fails, do a pg_basebackup.
11:12:30 INFO  The primary node returned by the monitor is pg-slave:5432
11:12:30 INFO  Rewinding PostgreSQL to follow new primary pg-slave:5432
11:12:30 ERROR Connection to database failed: could not connect to server: No such file or directory
	Is the server running locally and accepting
	connections on Unix domain socket "/var/run/postgresql/.s.PGSQL.5432"?

11:12:30 ERROR Failed to get the postgresql.conf path from the local postgres server, see above for details
11:12:30 WARN  Failed to rewind demoted primary to standby, trying pg_basebackup instead
11:12:30 INFO  Initialising PostgreSQL as a hot standby
11:12:30 INFO  Target directory exists: "/var/lib/postgresql/11/main", stopping PostgreSQL
11:12:30 INFO  pg_ctl: no server running

11:12:30 INFO  pg_ctl stop failed, but PostgreSQL is not running anyway
11:12:30 INFO  Running /usr/lib/postgresql/11/bin/pg_basebackup -w -h pg-slave -p 5432 --pgdata /var/lib/postgresql/11/backup -U pgautofailover_replicator --write-recovery-conf --max-rate 100M --wal-method=stream --slot pgautofailover_standby ...
11:12:33 INFO  pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/12000028 on timeline 6
pg_basebackup: starting background WAL receiver
    0/46937 kB (0%), 0/1 tablespace (...ostgresql/11/backup/backup_label)
46947/46947 kB (100%), 0/1 tablespace (...esql/11/backup/global/pg_control)
46947/46947 kB (100%), 1/1 tablespace                                         
pg_basebackup: write-ahead log end point: 0/120000F8
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: base backup completed

11:12:33 INFO  Postgres is not running, starting postgres
11:12:33 INFO   /usr/lib/postgresql/11/bin/pg_ctl --pgdata /var/lib/postgresql/11/main --options "-p 5432" --options "-h *" --wait start
11:12:33 INFO  PostgreSQL started on port 5432
11:12:33 INFO  Drop replication slot "pgautofailover_standby"
11:12:33 INFO  Transition complete: current state is now "catchingup"
11:12:33 INFO  Calling node_active for node default/1/0 with current state: catchingup, PostgreSQL is running, sync_state is "", WAL delta is -1.
11:12:38 INFO  Calling node_active for node default/1/0 with current state: catchingup, PostgreSQL is running, sync_state is "", WAL delta is -1.
11:12:43 INFO  Calling node_active for node default/1/0 with current state: catchingup, PostgreSQL is running, sync_state is "", WAL delta is -1.
11:12:48 INFO  Calling node_active for node default/1/0 with current state: catchingup, PostgreSQL is running, sync_state is "", WAL delta is -1.
11:12:48 INFO  FSM transition from "catchingup" to "secondary": Convinced the monitor that I'm up and running, and eligible for promotion again
11:12:48 INFO  Transition complete: current state is now "secondary"
11:12:48 INFO  Calling node_active for node default/1/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
11:12:53 INFO  Calling node_active for node default/1/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
11:12:58 INFO  Calling node_active for node default/1/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
11:13:03 INFO  Calling node_active for node default/1/0 with current state: secondary, PostgreSQL is running, sync_state is "", WAL delta is 0.
```

可以看到 pg_auto_failover 偵測到了cluster node 有意異動，開始同步資料，然後切換角色，從primary變成了 secondary


同一時間，在pg-slave 的訊息也有變動
```
03:12:34 INFO  Calling node_active for node default/4/0 with current state: wait_primary, PostgreSQL is running, sync_state is "async", WAL delta is 0.
03:12:39 INFO  Calling node_active for node default/4/0 with current state: wait_primary, PostgreSQL is running, sync_state is "async", WAL delta is 0.
03:12:45 INFO  Calling node_active for node default/4/0 with current state: wait_primary, PostgreSQL is running, sync_state is "async", WAL delta is 0.
03:12:50 INFO  Calling node_active for node default/4/0 with current state: wait_primary, PostgreSQL is running, sync_state is "async", WAL delta is 0.
03:12:50 INFO  FSM transition from "wait_primary" to "primary": A healthy secondary appeared
03:12:50 INFO  Enabling synchronous replication
03:12:50 INFO  Transition complete: current state is now "primary"
03:12:50 INFO  Calling node_active for node default/4/0 with current state: primary, PostgreSQL is running, sync_state is "sync", WAL delta is 0.
03:12:55 INFO  Calling node_active for node default/4/0 with current state: primary, PostgreSQL is running, sync_state is "sync", WAL delta is 0.
```

pg-slave 的狀態從原本的secondary 變成了 primary

來檢查看看
```
2019-09-20 03:19:04 [administrator@pg-slave ~]$ sudo runuser -l postgres -c "pg_autoctl show state"
      Name |   Port | Group |  Node |     Current State |    Assigned State
-----------+--------+-------+-------+-------------------+------------------
pg-primary |   5432 |     0 |     1 |         secondary |         secondary
  pg-slave |   5432 |     0 |     4 |           primary |           primary

2019-09-20 03:19:07 [administrator@pg-slave ~]$ 
```

跟上面第一次執行的結果不同了，兩台角色互換了，這也是預期中的結果

那在pg-master 離線期間的異動資料呢？在 pg-master上查得到嗎？

先透過 URI存取DB 檢查看看

```
2019-09-20 11:12:16 [administrator@pg-primary ~]$ sudo runuser -l postgres -c "psql postgres://pg-slave:5432,pg-primary:5432/postgres?target_session_attrs=read-write"
psql (11.5 (Ubuntu 11.5-1.pgdg18.04+1))
Type "help" for help.

postgres=# \l
                              List of databases
    Name     |  Owner   | Encoding  | Collate | Ctype |   Access privileges   
-------------+----------+-----------+---------+-------+-----------------------
 nexus       | postgres | SQL_ASCII | C       | C     | 
 postgres    | postgres | SQL_ASCII | C       | C     | 
 template0   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 template1   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 testdb_1058 | postgres | SQL_ASCII | C       | C     | 
 testdb_1108 | postgres | SQL_ASCII | C       | C     | 
(6 rows)

postgres=# select * from testtbl_1108;
 serial 
--------
    999
    888
     77
     66
     55
(5 rows)

postgres=#
```

GOOD！看來資料也同步過來了

再來看看單機的狀態
```
2019-09-20 11:22:07 [administrator@pg-primary ~]$ sudo runuser -l postgres -c "psql"
psql (11.5 (Ubuntu 11.5-1.pgdg18.04+1))
Type "help" for help.

postgres=# \l
                              List of databases
    Name     |  Owner   | Encoding  | Collate | Ctype |   Access privileges   
-------------+----------+-----------+---------+-------+-----------------------
 nexus       | postgres | SQL_ASCII | C       | C     | 
 postgres    | postgres | SQL_ASCII | C       | C     | 
 template0   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 template1   | postgres | SQL_ASCII | C       | C     | =c/postgres          +
             |          |           |         |       | postgres=CTc/postgres
 testdb_1058 | postgres | SQL_ASCII | C       | C     | 
 testdb_1108 | postgres | SQL_ASCII | C       | C     | 
(6 rows)

postgres=# select * from testtbl_1108;
 serial 
--------
    999
    888
     77
     66
     55
(5 rows)

postgres=# 
```

很好，確認資料有正確的抄寫過來！

***

以上測試可以發現 pg_auto_failover 這個postgresql的extension 還真的很好用！

設定簡單、快速、方便，設定完成後也不用傷腦筋，反正有異常，會自動幫你搞定master-slave之間的主從關係

資料也都會自動同步好，真的是非常推薦啊！
